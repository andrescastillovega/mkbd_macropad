## Project Memories

### ZMK display widget template

Standard Widget Structure Pattern:
  // widget_name.h
  #pragma once
  #include <lvgl.h>
  #include <zephyr/kernel.h>

  struct zmk_widget_[name] {
      sys_snode_t node;    // For widget list management
      lv_obj_t *obj;       // LVGL object pointer
  };

  int zmk_widget_[name]_init(struct zmk_widget_[name] *widget, lv_obj_t *parent);
  lv_obj_t *zmk_widget_[name]_obj(struct zmk_widget_[name] *widget);

  Implementation Template:
  // widget_name.c
  #include <zephyr/kernel.h>
  #include <zmk/display.h>
  #include <zmk/event_manager.h>
  #include <zmk/events/[relevant_events].h>

  static sys_slist_t widgets = SYS_SLIST_STATIC_INIT(&widgets);

  struct widget_state {
      // State fields that drive display updates
  };

  static void widget_update_cb(struct widget_state state) {
      struct zmk_widget_[name] *widget;
      SYS_SLIST_FOR_EACH_CONTAINER(&widgets, widget, node) {
          // Update widget display based on state
          lv_label_set_text(widget->obj, "updated_text");
      }
  }

  static struct widget_state get_state(const zmk_event_t *eh) {
      return (struct widget_state){
          // Extract state from ZMK systems
      };
  }

  // Core macro that handles thread-safe event management
  ZMK_DISPLAY_WIDGET_LISTENER(widget_[name], struct widget_state,
                              widget_update_cb, get_state)

  // Subscribe to relevant events
  ZMK_SUBSCRIPTION(widget_[name], zmk_[event_type]);

  int zmk_widget_[name]_init(struct zmk_widget_[name] *widget, lv_obj_t *parent) {
      widget->obj = lv_label_create(parent);
      // Configure LVGL properties
      sys_slist_append(&widgets, &widget->node);
      widget_[name]_init();  // Generated by macro
      return 0;
  }

  lv_obj_t *zmk_widget_[name]_obj(struct zmk_widget_[name] *widget) {
      return widget->obj;
  }

  Key Components

  1. ZMK_DISPLAY_WIDGET_LISTENER macro - Core template that provides thread-safe event handling
  2. Widget list management using sys_slist_t for multiple instances
  3. State structure defining what data drives the display
  4. Event subscriptions using ZMK_SUBSCRIPTION macro
  5. Standard init/accessor functions for widget lifecycle

  Configuration Template

  Kconfig:
  config ZMK_WIDGET_[NAME]
      bool "Widget description"
      depends on ZMK_DISPLAY
      select LV_USE_LABEL

  CMakeLists.txt:
  target_sources_ifdef(CONFIG_ZMK_WIDGET_[NAME] app PRIVATE widget_name.c)

  The community has created additional templates and examples (like zmk-nice-oled) that extend this basic pattern with custom graphics and layouts. ZMK recommends using their module
  template system for distributing custom widgets.

### How to Update P1 Keyboard Display Image

When you need to update the P1_screen.svg image displayed when charging:

1. **Edit the SVG file**: Update `P1_screen.svg` in the project root
2. **Convert to PNG**: The conversion script will automatically detect the updated SVG
3. **Regenerate LVGL data**: Run the conversion script to update the C array:
   ```bash
   cd /home/avena/Documents/projects/mkbd_macropad
   python3 convert_png.py
   ```
4. **Files automatically updated**: 
   - `P1_screen.png` - Generated bitmap
   - `boards/shields/mkbd_macropad/p1_keyboard_img.c` - LVGL image data

The custom status screen (`custom_status_screen.c`) will automatically use the updated image data when USB is connected (charging mode).

**Note**: The image is sized for the 128x32 OLED display and converted to 1-bit monochrome format for optimal memory usage.